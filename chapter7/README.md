# csapp - 第7章 链接

**链接(linking)**: 将各种代码和数据片段手机并组合成为一个单一文件的过程, 这个文件可被**加载**(复制)到内存并执行.

链接可以执行的时期:

* 编译时(compile time): 源代码被翻译成机器代码时
* 加载时(load time): 程序被**加载器(loader)**加载到内存并执行时
* 运行时(run time): 由应用程序来执行

在早期的计算机系统中, 链接是手动执行的. 在现代系统中, 链接是由叫做**链接器(linker)**的程序自动执行的.

链接器在软件开发中扮演着一个关键的角色, 因为它们使得**分离编译(separate compilation)**称为可能.

为什么要学关于链接的知识?

* 理解链接器将帮助你构造大型程序
* 理解链接器将帮助你避免一些危险的编程错误
* 理解链接将帮助你理解语言的作用域规则是如何实现的
* 理解链接将帮助你理解其他重要的系统概念
* 理解链接将使你能够利用共享库

### 7.2 静态链接

链接器必须完成2个主要任务：

* 符号解析（symbol resolution）。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（static），符号解析的目的是将每个符号引用正好和一个符号定义关联起来
* 重定位（relocation）

### 7.3 目标文件

* 可重定位目标文件：二进制代码和数据，可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件
* 可执行目标文件：二进制形式的代码和数据，可以直接复制到内存并执行
* 共享目标文件：特殊类型的可重定位目标文件，可以在加载或者运行时被**动态地**加载进内存并链接

现代x86-64 Linux 和 Unix系统使用**可执行链接格式（Executable and Linkable Format, ELF）**

### 7.4 可重定位目标文件

ELF头（ELF header）以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。

* ELF头的大小
* 目标文件的类型（如可重定位、可执行或者共享的）
* 机器类型（如x86-64）
* 节头部表（section header table）的文件偏移
* 节头部表中条目的大小和数量

夹在ELF头和节头部表之间的都是节（section）

尝试理解每个section的内容以及作用

### 7.5 符号和符号表

每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有3中不同的符号

* 有模块m定义并能被其他模块引用的全局符号。对应于**非静态的C函数和全局变量**
* 由其他模块定义并被模块m引用的全局符号。称为**外部符号**，对应于在其他模块中定义的**非静态C函数和全局变量**
* 只被模块m定义和引用的局部符号。对应带**static属性**的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。

### 7.6 符号解析

链接器解析符号引用的方法是：将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来

如果多个模块定义同名的全局符号，会发生什么呢？

在编译时，编译器向汇编器输出每个全局符号，分为2类符号

* 强（strong）： **函数**和已初始化的全局变量
* 弱（weak)：未初始化的全局变量是弱符号

Linux链接器使用下面的规则来处理多重定义的符号名

1. 不允许有多个同名的强符号
2. 如果有一个强符号和多个弱符号同名，那么选择强符号
3. 如果有多个弱符号同名，那么从这些弱符号中任意选一个

多重定义的全局符号可能会带来非常难调的bug

可以在GCC中加入如下参数来捕获这类程序，进而定位在哪里多重定义了

`-fno-common`告诉链接器，在遇到多重定义的全局符号时，触发一个错误。

`-Werror`把所有的警告都变为错误。

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为**静态库（static library）**，它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

使用库函数时，比如`sqrt(), sin()`等，怎么给程序员提供可靠的函数呢？

一种方法是编译器里放入这些函数的具体实现，但是会增加编译器的复杂性，而且每次添加或者修改一个标准函数时，就需要一个新的编译器版本。

另一种方法是将所有的标准C函数都放在一个单独的可重定位目标模块中（比如libc.o中），应用程序员可以把这个模块链接到他们的可执行文件中。这种方法的优点是它将编译器的实现与标准函数实现分离开来，并且仍然对程序员保持适度的便利。但是，一个很大的缺点是系统中每个可执行文件现在都包含这一份标准函数集合的完全副本，这对磁盘空间是很大的浪费（libc.a大约5M）。更糟糕的是，每个正在运行的程序都将它自己的这些函数的副本放在内存中，这是对内存的极度浪费，另一个大的缺点是，对任何标准函数的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变得很复杂。