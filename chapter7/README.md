# csapp - 第7章 链接

**链接(linking)**: 将各种代码和数据片段手机并组合成为一个单一文件的过程, 这个文件可被**加载**(复制)到内存并执行.

链接可以执行的时期:

* 编译时(compile time): 源代码被翻译成机器代码时
* 加载时(load time): 程序被**加载器(loader)**加载到内存并执行时
* 运行时(run time): 由应用程序来执行

在早期的计算机系统中, 链接是手动执行的. 在现代系统中, 链接是由叫做**链接器(linker)**的程序自动执行的.

链接器在软件开发中扮演着一个关键的角色, 因为它们使得**分离编译(separate compilation)**称为可能.

为什么要学关于链接的知识?

* 理解链接器将帮助你构造大型程序
* 理解链接器将帮助你避免一些危险的编程错误
* 理解链接将帮助你理解语言的作用域规则是如何实现的
* 理解链接将帮助你理解其他重要的系统概念
* 理解链接将使你能够利用共享库

### 7.2 静态链接

链接器必须完成2个主要任务：

* 符号解析（symbol resolution）。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（static），符号解析的目的是将每个符号引用正好和一个符号定义关联起来
* 重定位（relocation）

### 7.3 目标文件

* 可重定位目标文件：二进制代码和数据，可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件
* 可执行目标文件：二进制形式的代码和数据，可以直接复制到内存并执行
* 共享目标文件：特殊类型的可重定位目标文件，可以在加载或者运行时被**动态地**加载进内存并链接

现代x86-64 Linux 和 Unix系统使用**可执行链接格式（Executable and Linkable Format, ELF）**

### 7.4 可重定位目标文件

ELF头（ELF header）以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。

* ELF头的大小
* 目标文件的类型（如可重定位、可执行或者共享的）
* 机器类型（如x86-64）
* 节头部表（section header table）的文件偏移
* 节头部表中条目的大小和数量

夹在ELF头和节头部表之间的都是节（section）

尝试理解每个section的内容以及作用

### 7.5 符号和符号表

每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有3中不同的符号

* 有模块m定义并能被其他模块引用的全局符号。对应于**非静态的C函数和全局变量**
* 由其他模块定义并被模块m引用的全局符号。称为**外部符号**，对应于在其他模块中定义的**非静态C函数和全局变量**
* 只被模块m定义和引用的局部符号。对应带**static属性**的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。

### 7.6 符号解析

链接器解析符号引用的方法是：将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来

如果多个模块定义同名的全局符号，会发生什么呢？

在编译时，编译器向汇编器输出每个全局符号，分为2类符号

* 强（strong）： **函数**和已初始化的全局变量
* 弱（weak)：未初始化的全局变量是弱符号

Linux链接器使用下面的规则来处理多重定义的符号名

1. 不允许有多个同名的强符号
2. 如果有一个强符号和多个弱符号同名，那么选择强符号
3. 如果有多个弱符号同名，那么从这些弱符号中任意选一个

多重定义的全局符号可能会带来非常难调的bug

可以在GCC中加入如下参数来捕获这类程序，进而定位在哪里多重定义了

`-fno-common`告诉链接器，在遇到多重定义的全局符号时，触发一个错误。

`-Werror`把所有的警告都变为错误。

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为**静态库（static library）**，它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

使用库函数时，比如`sqrt(), sin()`等，怎么给程序员提供可靠的函数呢？

一种方法是编译器里放入这些函数的具体实现，但是会增加编译器的复杂性，而且每次添加或者修改一个标准函数时，就需要一个新的编译器版本。

另一种方法是将所有的标准C函数都放在一个单独的可重定位目标模块中（比如libc.o中），应用程序员可以把这个模块链接到他们的可执行文件中。这种方法的优点是它将编译器的实现与标准函数实现分离开来，并且仍然对程序员保持适度的便利。但是，一个很大的缺点是系统中每个可执行文件现在都包含这一份标准函数集合的完全副本，这对磁盘空间是很大的浪费（libc.a大约5M）。更糟糕的是，每个正在运行的程序都将它自己的这些函数的副本放在内存中，这是对内存的极度浪费，另一个大的缺点是，对任何标准函数的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变得很复杂。

在linux中，静态库以一种称为**存档（archive）**的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置

链接是有算法的，而这种算法（在`P478`）会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败

```shell
gcc -static ./libvector.a main2.c
```

关于库的一般准则是将它们放在命令行的结尾。

如果库不是相互独立的，那么必须对它们排序，使得对于每个被存档的文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在对s的引用之后的

### 7.7 重定位(Relocation)

一旦链接器完成了符号解析，接下来是解决符号的引用问题

symbol definition: a symbol table entry is one of its input object modules

在此时链接器知道：

* the exact sizes of the code and data sections in its input object modules

现在开始重定位，会将输入模块里的每个符号都赋予一个运行时的地址，包含两个步骤

* Relocating sections and symbol definitions
* Relocating symbol references within sections

### 7.9 加载可执行目标文件

将程序复制到内存并运行的过程叫做**加载**。

在linux x86-64系统中，代码段总是从地址`0x400000`处开始，后面是数据段。

运行时堆在数据段之后，通过调用`malloc`库往上增长。

堆后面的区域是为共享模块保留的。

用户栈总是从最大的合法用户地址（2^48 - 1 ）开始，向较小内存地址增长。

栈上的区域，从地址2^48开始，是为内核（kernel）中的代码和数据保留的

内核就是操作系统驻留在内存的部分。

由于`.data`段有对齐要求，所以代码段和数据段之间是有间隙的

### 7.10 动态链接共享库

静态库有一些明显的缺点

同所有的软件一样，静态库需要定期维护和更新

如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。

另一问题是几乎每个C程序都使用标准`I/O`函数，比如`printf, scanf`。在运行时，这些函数的代码会被复制到每个进程的文本段中。在一个运行上百个进程的典型系统上，这是对稀缺的内存系统资源的极大浪费。（内存的一个有趣属性就是不论系统的内存有多大，它总是一种稀缺资源，磁盘空间和厨房的垃圾桶同样有这种属性）

**共享库（shared library）**是致力于解决静态库缺陷的一个现代创新产物。

共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为**动态链接（dynamic linking）** ，是由一个叫做**动态链接器（dyna linker）**的程序来执行的。

共享库也称共享目标（shared object），在Linux系统中通常用`.so`后缀来表示。微软的操作系统大量地使用了共享库，它们称为DLL（动态链接库）。

共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的代码，因而节约宝贵的内存资源。

那么，多个进程是如何共享程序的一个副本呢？

一种方法是给每个共享库分配一个实现准备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。这种方法虽然简单，但是它也造成了一些严重的问题。

要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用这种方法，无线多个进程可以共享一个共享模块的代码段的单一副本。（当然，每个进程仍然会有它自己的读/写数据块。）

可以加载而无需重定位的代码称为**位置无关代码（Position-Independent Code，PIC）**，用户对GCC使用`-fpic`选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。

编译器通过运用以下这个有趣的事实来生成对全局变量的PIC引用：无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。

对于共享模块定义的外部过程和对全局变量的引用需要一些特殊的技巧。