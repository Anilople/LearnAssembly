# CSAPP - 第5章优化程序性能

## 5.1 优化编译器的能力和局限性

编写高效程序需要做到

* 选择一组适当的算法和数据结构
* 编写出编译器能够有效优化以转换成高效可执行代码的源代码，对于这一点，理解优化编译器的能力和局限性是很重要的，不同的编程语言之间，在这一点的优化上难度也不一样。C语言的有些特性，例如执行**指针运算和强制类型转换**的能力，使得编译器很难对它进行优化
* 针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行地计算

通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。

算法级上：几分钟就能编写一个简单的插入排序，而一个高效的排序算法程序可能需要一天或更长的时间来实现和优化。

代码级上：许多低级别的优化往往会降低程序的可读性和模块性，使得程序容易出错，并且更难修改或拓展

即使是最好的编译器也受到**妨碍优化的因素（optimization blocker）**的阻碍，妨碍优化的因素就是程序行为中那些严重依赖于执行环境的方面

程序优化

1. 消除不必要的工作，包括不必要的函数调用、条件测试和内存引用等。
2. 了解处理器的运作，利用处理器提供的**指令级并行（instruction-level parallelism）**能力，同时执行多条指令。

两个指针可能指向同一个内存位置的情况称为**内存别名使用（memory aliasing）**，在只执行安全的优化中，编译器必须假设不**同的指针可能会指向内存中同一个位置**。（生动的例子在`Page 343`，展示了为什么**有些优化只能由人来做**，编译器无法完成）

## 5.2 表示程序性能

度量程序性能的标准：每元素的周期数（Cycles Per Element，CPE），这种度量标准帮助我们在更细节的级别上理解迭代程序的循环性能。

从程序员的角度来看，用**时钟周期**来表示度量标准要比用纳秒或皮秒来表示有帮助得多。用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行得有多块。

**循环展开（loop unrolling）**

在`Page347`，若`psum1`的运行时间为`368+9.0n`，`psum2`的运行时间为`368+6.0n`，则`psum1`的CPE为`9.0`，`psum2`的CPE为`6.0`。

在一个具有`Intel Core i7 Haswell`处理器的机器上测量这些函数的CPE性能，这个机器成为**参考机**。

## 5.4 消除循环的效率

**代码移动（code motion）**：这类优化包括识别要执行多次但是计算结果不会改变的计算。比如在循环中，如果每次访问的值都不会改变，比如**向量长度**，就可以将这个值存到寄存器中，这样就不用每次都访问内存取出这个值了。

## 5.6 消除不必要的内存引用

## 5.7 理解现代处理器

实际的处理器，是同事对多条指令求值的，这个现象称为**指令级并行**。

有2中下界描述了程序的最大性能：

* 延迟界限（latency bound）：当一系列操作必须按照严格顺序执行时，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。
* 吞吐量界限（throughpu bound）：刻画了处理器功能单元的原始计算能力，是程序性能的终极界限。