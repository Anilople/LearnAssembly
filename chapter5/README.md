# CSAPP - 第5章优化程序性能

## 5.1 优化编译器的能力和局限性

编写高效程序需要做到

* 选择一组适当的算法和数据结构
* 编写出编译器能够有效优化以转换成高效可执行代码的源代码，对于这一点，理解优化编译器的能力和局限性是很重要的，不同的编程语言之间，在这一点的优化上难度也不一样。C语言的有些特性，例如执行**指针运算和强制类型转换**的能力，使得编译器很难对它进行优化
* 针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行地计算

通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。

算法级上：几分钟就能编写一个简单的插入排序，而一个高效的排序算法程序可能需要一天或更长的时间来实现和优化。

代码级上：许多低级别的优化往往会降低程序的可读性和模块性，使得程序容易出错，并且更难修改或拓展

即使是最好的编译器也受到**妨碍优化的因素（optimization blocker）**的阻碍，妨碍优化的因素就是程序行为中那些严重依赖于执行环境的方面

程序优化

1. 消除不必要的工作，包括不必要的函数调用、条件测试和内存引用等。
2. 了解处理器的运作，利用处理器提供的**指令级并行（instruction-level parallelism）**能力，同时执行多条指令。

两个指针可能指向同一个内存位置的情况称为**内存别名使用（memory aliasing）**，在只执行安全的优化中，编译器必须假设不**同的指针可能会指向内存中同一个位置**。（生动的例子在`Page 343`，展示了为什么**有些优化只能由人来做**，编译器无法完成）

## 5.2 表示程序性能

度量程序性能的标准：每元素的周期数（Cycles Per Element，CPE），这种度量标准帮助我们在更细节的级别上理解迭代程序的循环性能。

从程序员的角度来看，用**时钟周期**来表示度量标准要比用纳秒或皮秒来表示有帮助得多。用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行得有多块。

**循环展开（loop unrolling）**

在`Page347`，若`psum1`的运行时间为`368+9.0n`，`psum2`的运行时间为`368+6.0n`，则`psum1`的CPE为`9.0`，`psum2`的CPE为`6.0`。

在一个具有`Intel Core i7 Haswell`处理器的机器上测量这些函数的CPE性能，这个机器成为**参考机**。

## 5.4 消除循环的效率

**代码移动（code motion）**：这类优化包括识别要执行多次但是计算结果不会改变的计算。比如在循环中，如果每次访问的值都不会改变，比如**向量长度**，就可以将这个值存到寄存器中，这样就不用每次都访问内存取出这个值了。

## 5.6 消除不必要的内存引用

## 5.7 理解现代处理器

实际的处理器，是同事对多条指令求值的，这个现象称为**指令级并行**。

有2中下界描述了程序的最大性能：

* 延迟界限（latency bound）：当一系列操作必须按照严格顺序执行时，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。
* 吞吐量界限（throughpu bound）：刻画了处理器功能单元的原始计算能力，是程序性能的终极界限。

处理器可以在每个时钟周期执行多个操作，而且是**乱序的（out-of-order）**，意思就是指令的执行顺序不一定要与它们在机器级程序中的顺序一致。

* 指令控制单元（Instruction Control Unit，ICU）：负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作。
* 执行单元（Execution Unit，EU）：执行这些操作。

有时候，将

![](http://latex.codecogs.com/gif.latex?\\a_0 + a_1 x + a_2 x^2 + \cdots + a_n x^2 \quad (1))

优化为

![](http://latex.codecogs.com/gif.latex?\\a_0 + x (a_1 +x(a_2+ \cdots + x(a_{n-1} + x a_n)\quad (2)) 

不一定会使得程序运行更快。因为cpu可能会并行处理一些运算，使得（1）比（2）更快。

## 5.8 循环展开

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。

利用CPU的并行，可以将多条非耦合的语句（就是在计算上可以并行的语句）放在同一个循环上，进而降低循环次数，而CPU也可以在每次迭代中执行更多的运算。

`acc = acc OP (data[i] OP data[i+1])`比`acc = （acc OP data[i]） OP data[i+1]`快，括号的位置不一样，这种操作叫**重新结合变换（reassociation transformation）**，因为后者在每次迭代内的第一个乘法都不需要等待前一次迭代的累积值就可以执行。

通常，我们发现循环展开和并行地累积在多个值中，是提高程序性能的更可靠的方法。

在一个程序的数据流图表示中，**关键路径**指明了执行该程序所需时间的一个基本的下界。也就是说，如果程序中有某条数据相关链，这条链上的所有延迟之和等于T，那么这个程序至少需要T个周期才能执行完。

## 5.14 确认和消除性能瓶颈

程序剖析（profiling）：运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。

`Unit`系统提供了一个剖析程序`GPROF`，它会产生2种形式的信息：

* 程序中每个函数花费了多少CPU时间
* 每个函数被调用的次数

使用方法如下，

1. 程序必须为剖析而编译和链接。使用GCC时，就是在命令行上加入参数`-pg`。确保编译器不通过内联替换来尝试执行优化是很重要的。

   ```c
   linux> gcc -Og -pg prog.c -o prog
   ```

2. 程序像往常一样执行，但是会产生一个额外的文件`gmon.out`

   ```c
   linux> ./prog file.txt # file.txt这文本文件就算程序不用也要加上去
   ```

3. 调用GPROF来分析`gmon.out`中的数据

   ```c
   linux> grpof prog
   ```

   ​