# 深入理解计算机系统 - 第3章

```shell
# p1.c p2.c
gcc -Og -o p p1.c p2.c

# gcc 指 GCC C 编译器， 也可以用 cc 来启动它
# -Og 告诉编译器使用会生产符合原始C代码整体结构的机器代码的优化等级， 
# 对于一些编译器，可以用 -O1 替代 -Og
```

对于**机器级的编程**， **2种抽象**最重要

* ISA(Instruction Set Architecture). 由指令集体系结构来定义机器级程序的格式和行为
* 机器级程序使用的内存地址是虚拟地址

```c
// 文件名： mstore.c
long mult2(long,long);

void multstore(long x,long y, long * dest){
	long t = mult2(x,y);
	*dest = t;
}
```

```shell
gcc -Og -S mstore.c # 产生汇编代码 mstore.s， ATT风格
gcc -Og -S -masm=intel mstore.c # Intel风格汇编
gcc -Og -c mstore.c # 产生机器代码 mstore.o
# 使用gdb查看mstore.o 的二进制代码
$ gdb mstore.o
(gdb) x/14b multstore # 查看从函数multstore所处地址开始的14个hex
$ objdump -d mstore.o # 查看反汇编
```

在C程序中插入汇编代码有2种方法：

* 编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来。
* 使用GCC的内联汇编(inline assembly)特性，用asm伪指令

x86-64对`mov`系列的指令加了1条限制，传送指令的2个操作数**不能都**指向内存位置

| C声明  | Intel数据类型 | 汇编代码后缀 | 大小（byte） |
| ------ | ------------- | ------------ | ------------ |
| char   | byte（字节）  | b            | 1            |
| short  | word（字）    | w            | 2            |
| int    | double word   | l            | 4            |
| long   | 四字          | q            | 8            |
| char * | 四字          | q            | 8            |
| float  | 单精度        | s            | 4            |
| double | 双精度        | l            | 8            |



> 注意：大多数情况，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0. 这是历史遗留问题，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0.

`movz`系列指令把目的中剩余的字节填充为0

`movs`系列指令通过符号扩展来填充

`INC`和`DEC`会改变`OF`和`ZF`，但是不会改变`CF`

基于条件数据传送的代码会比基于条件控制转移的代码性能要好。

在第5章中将会看到，处理器通过使用流水线（pipelining）来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器。）控制流不依赖于数据，使得处理器更容易保持流水线是满的。

条件传送码如`cmove`等，源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。

> 8bit的数据，也就是单字节不可以用条件传送

```c
// 用goto取翻译以下循环控制结构
do {
    body-statement;
}while(test-exp);

while(test-exp){
    body-statement;
}

for(...; test-exp ;...){
    body-statement;
}

// 再将goto翻译为基本的jne等汇编语句
    
```



在不同的编程语言中，过程的形式多样化：

* function -- 函数
* method -- 方法
* subroutine -- 子例程
* handler -- 处理函数

对过程的机器级支持，必须要处理许多不同的属性。假设过程P调用过程Q，Q执行后返回到P。这些动作包含以下一个或多个机制：

* 传递控制。
* 传递数据。
* 分配和释放内存。

当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分成为过程的栈帧(stack fram)。

过程Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以**保持寄存器的值，分配局部变量空间，为它调用的过程设置参数**。

有些时候，局部数据必须放在内存中，常见的情况包括：

* 寄存器不够用。
* 对一个局部变量使用地址运算符'&'，因此必须能够为它产生一个地址。
* 某些局部变量是数组或结构，因此必须能够通过数据或结构引用被访问到。

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有1个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

根据惯例，寄存器`%rbx,%rbp`和`%r12~%r15`被划分为**被调用者保存**寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。

无论数据是否对齐，x86-64硬件都能正确工作。不过，Intel还是建议要对齐数据以提高内存系统的性能。**对齐原则**是任何`K`字节的基本对象的地址必须是`K的倍数`。比如，`long`的起始地址为`8`的倍数，`int`为`4`的倍数，short为`2`的倍数。

理解机器级程序如何帮助我们研究**缓冲区一处**，这是现实世界许多系统中一种很重要的安全漏洞。（可以使用调试器GDB）

`malloc`函数返回一个通用指针，然后通过**显式强制类型转换**或者赋值操作那样的**隐式强制类型转换**，将它转换成一个有类型的指针。

指针的特性如下：

* 每个指针都对应一个类型。
* 每个指针都有一个值。
* 指针用`&`运算符创建。
* `*`操作符用于间接引用指针。
* 数组与指针紧密联系。一个数组的名字可以像1个指针变量一样引用（但是不能修改）。
* 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
* 指针也可以指向函数。`int (*fp)(int, int *);`



