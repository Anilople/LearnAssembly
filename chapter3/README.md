# 深入理解计算机系统 - 第3章

```shell
# p1.c p2.c
gcc -Og -o p p1.c p2.c

# gcc 指 GCC C 编译器， 也可以用 cc 来启动它
# -Og 告诉编译器使用会生产符合原始C代码整体结构的机器代码的优化等级， 
# 对于一些编译器，可以用 -O1 替代 -Og
```

对于**机器级的编程**， **2种抽象**最重要

* ISA(Instruction Set Architecture). 由指令集体系结构来定义机器级程序的格式和行为
* 机器级程序使用的内存地址是虚拟地址

```c
// 文件名： mstore.c
long mult2(long,long);

void multstore(long x,long y, long * dest){
	long t = mult2(x,y);
	*dest = t;
}
```

```shell
gcc -Og -S mstore.c # 产生汇编代码 mstore.s， ATT风格
gcc -Og -S -masm=intel mstore.c # Intel风格汇编
gcc -Og -c mstore.c # 产生机器代码 mstore.o
# 使用gdb查看mstore.o 的二进制代码
$ gdb mstore.o
(gdb) x/14b multstore # 查看从函数multstore所处地址开始的14个hex
$ objdump -d mstore.o # 查看反汇编
```

在C程序中插入汇编代码有2种方法：

* 编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来。
* 使用GCC的内联汇编(inline assembly)特性，用asm伪指令

x86-64对`mov`系列的指令加了1条限制，传送指令的2个操作数**不能都**指向内存位置

### 数据类型

| C声明  | Intel数据类型 | 汇编代码后缀 | 大小（byte） |
| ------ | ------------- | ------------ | ------------ |
| char   | byte（字节）  | b            | 1            |
| short  | word（字）    | w            | 2            |
| int    | double word   | l            | 4            |
| long   | 四字          | q            | 8            |
| char * | 四字          | q            | 8            |
| float  | 单精度        | s            | 4            |
| double | 双精度        | l            | 8            |

### 数据传送

> 注意：大多数情况，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0. 这是历史遗留问题，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0.

`movz`系列指令把目的中剩余的字节填充为0

`movs`系列指令通过符号扩展来填充

`INC`和`DEC`会改变`OF`和`ZF`，但是不会改变`CF`

基于条件数据传送的代码会比基于条件控制转移的代码性能要好。

在第5章中将会看到，处理器通过使用流水线（pipelining）来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器。）控制流不依赖于数据，使得处理器更容易保持流水线是满的。

条件传送码如`cmove`等，源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。

> 8bit的数据，也就是单字节不可以用条件传送

### 循环结构

```c
// 用goto取翻译以下循环控制结构
do {
    body-statement;
}while(test-exp);

while(test-exp){
    body-statement;
}

for(...; test-exp ;...){
    body-statement;
}

// 再将goto翻译为基本的jne等汇编语句
    
```

### 过程

在不同的编程语言中，过程的形式多样化：

* function -- 函数
* method -- 方法
* subroutine -- 子例程
* handler -- 处理函数

对过程的机器级支持，必须要处理许多不同的属性。假设过程P调用过程Q，Q执行后返回到P。这些动作包含以下一个或多个机制：

* 传递控制。
* 传递数据。
* 分配和释放内存。

当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分成为过程的栈帧(stack fram)。

过程Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以**保持寄存器的值，分配局部变量空间，为它调用的过程设置参数**。

有些时候，局部数据必须放在内存中，常见的情况包括：

* 寄存器不够用。
* 对一个局部变量使用地址运算符'&'，因此必须能够为它产生一个地址。
* 某些局部变量是数组或结构，因此必须能够通过数据或结构引用被访问到。

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有1个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

根据惯例，寄存器`%rbx,%rbp`和`%r12~%r15`被划分为**被调用者保存**寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。

### 数据对齐

无论数据是否对齐，x86-64硬件都能正确工作。不过，Intel还是建议要对齐数据以提高内存系统的性能。**对齐原则**是任何`K`字节的基本对象的地址必须是`K的倍数`。比如，`long`的起始地址为`8`的倍数，`int`为`4`的倍数，short为`2`的倍数。

理解机器级程序如何帮助我们研究**缓冲区一处**，这是现实世界许多系统中一种很重要的安全漏洞。（可以使用调试器GDB）

### 指针

`malloc`函数返回一个通用指针，然后通过**显式强制类型转换**或者赋值操作那样的**隐式强制类型转换**，将它转换成一个有类型的指针。

指针的特性如下：

* 每个指针都对应一个类型。
* 每个指针都有一个值。
* 指针用`&`运算符创建。
* `*`操作符用于间接引用指针。
* 数组与指针紧密联系。一个数组的名字可以像1个指针变量一样引用（但是不能修改）。
* 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
* 指针也可以指向函数。`int (*fp)(int, int *);`


### 内存越界引用和缓冲区溢出

C对数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。这2中情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。

缓冲区溢出(buffer overflow)是一种特别常见的状态破坏。调用一个过程Q的时候，在栈里存了一些信息（比如这个过程Q的返回地址，在调用过程Q前存储在栈里的`%rbx`等），但是在过程Q中声明了一些数据，字符数组等，因为这个数组的空间是在栈上开拓的，当对数组的访问越界时，就会访问到栈里的其他信息（返回地址等），栈里的信息被更改后，就会使得程序的运行有偏差。

#### 攻击

buffer overflow的1个更加致命的使用就是**让程序执行它本来不愿意执行的函数**。这是一种最常见的通过计算机网络攻击系统安全的方法。

通常的具体做法是，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，成为攻击代码(exploit code)，另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。然后，执行ret指令的效果就是跳转到攻击代码。

#### 对抗攻击

1. 栈随机化。为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。栈随机化的思想使得栈的位置在程序每次运行时都有变化。
2. 栈破坏检测。在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀(canary)值，也称为哨兵值(guard value)，这个值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在回复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作改变了。如果是被改变了，那么程序异常中止。
3. 限制可执行代码区域。即消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。

### 浮点代码

处理器的**浮点体系结构**包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

* 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。
* 对浮点数据操作的指令。
* 向函数传递浮点数参数和从函数返回浮点数结果的规则。
* 函数调用过程中保存寄存器的规则，例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。

我们的讲述基于`AVX2`，即`AVX`的第二个版本，它是在2013年`Core i7 Haswell`处理器中引入的。

用`GCC`编译时给定命令行参数`-mavx2`，`GCC`会生成`AVX2`代码。

`AVX`浮点体系结构允许数据存储在16个`YMM`寄存器中，它们的名字为`%ymm0~%ymm15`。每个`YMM`寄存器都是256位（32字节）。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（对于float）或者64位（对于double）。汇编代码用寄存器的`SSE XMM`寄存器名字`%xmm0~%xmm15`来引用它们，每个`XMM`寄存器都是对应的`YMM`寄存器的低128位（16字节）。

浮点数和整数之间的转换是有具体的机器指令支持的，`Page207`。

例如

```assembly
; 不太常见的3操作数格式，有2个源和1个目的。
vcvtsi2sdq %rax,%xmm1,%xmm1 ;从%rax读出一个长整数，把它转为double
; 第1个操作数读自于内存或者1个通用目的寄存器
; 这里可以忽略第2个操作数，因为它的值只会影响结果的高位字节
; 目标必须是XMM寄存器
```

### Boom lab

[lab官网地址](http://csapp.cs.cmu.edu/3e/labs.html)

#### phase_1

`Border relations with Canada have never been better.`

注意函数`strings_not_equal`参数为`rdi`和`rsi`，在调用前，`rsi`的值为某个内存地址，去查看那个地址里边存储的字符串即可。

#### phase_2

`1 2 4 8 16 32`

注意`read_six_number`用`sscanf`读入的数据会放在栈的哪块地方（依据函数参数传递规则）。

#### phase_3

`0 207`

`jmpq *0x402470(,%rax,8)`表示将内存`0x402470+%rax * 8 `中的`4个byte`当做`%rip`的值进行跳转，用`(gdb) x/10gx 0x402470 `来查看跳转表里边的地址，会发现有`8`个答案可以用。

| a    | b(hex) | b(dec) |
| ---- | ------ | ------ |
| 0    | 0xcf   | 207    |
| 1    | 0x137  | 311    |
| 2    | 0x2c3  | 707    |
| 3    | 0x100  | 256    |
| 4    | 0x185  | 389    |
| 5    | 0xce   | 206    |
| 6    | 0x2aa  | 682    |
| 7    | 0x147  | 327    |

将字符串	`“a b(dec)”`输入即可，例如`0 207`或者`6 682`。

#### phase_4

`7 0`

假设输入了2个数，名字为a和b，在函数`phase_4`内部，调用了函数`func4`，这个函数接收3个参数，返回1个参数，第1次调用时，参数为

```c
func4(a,0,7)
```

要选一个恰当的a，使得这个函数返回值为0，最简单的为选择a=7。

#### phase_5

`i?n567`

有多种可行的答案。

首先，输入的字符串S的长度必须为6。

程序对S进行操作，得到另一个长度为6的字符串D，要求D必须等于`flyers`，详细看地址`phase_5 +81 `的指令。

这个字符串D怎么得到的呢？$D_i = f(S_i)$，$f$将$S_i$ `& 0xf`得到下标$I_i$，然后用这个下标访问字符串数组`Arr`，详细看`phase_5 + 55`，得到$D_i = Arr[ \ I_i \ ]$。

因此，只要选取恰当的6个字符，就能从`Arr`中访问到对应的字符，使之能与`flyers`匹配。

| 第i个字符 | 低4bit要求 | 符合条件的字符集合（键盘可输入） |
| :-------: | :--------: | :------------------------------: |
|     0     |    0x9     |             `)9IYiy`             |
|     1     |    0xf     |             `/?O_o`              |
|     2     |    0xe     |             `.>N^n~`             |
|     3     |    0x5     |             `%5EUeu`             |
|     4     |    0x6     |             `&6FVfv`             |
|     5     |    0x7     |              '7GWgw              |

可以选`)/.%&'`，也可以选`9?NEFG`。