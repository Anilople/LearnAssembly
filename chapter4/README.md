# 深入理解计算机系统 - 第4章(处理器体系结构)

### 为什么要学这章?

* 有趣, 重要
* 理解处理器如何工作能帮助理解整个计算机系统如何工作
* 虽然很少有人设计处理器, 但是很多人设计包含处理器的硬件系统
* 你的工作可能就是处理器设计

## Y86-64指令集体系结构

15个寄存器`%rax,%rbx,%rcx,%rdx,%rsp,%rbp,%rsi,%rdi,%r8 ~ %r14`

3个flag标志位`ZF,SF,OF`

基本上是x86-64指令集的一个子集, 只包括8字节整数操作, 寻址方式和操作少.

#### 指令细节

* movq系列. `irmovq,rrmovq,mrmovq,rmmovq`.源可以是立即数(i), 寄存器(r)和内存(m). 目的可以是寄存器(r)和内存(m). 第1个字母代表源的类型, 第2个字母代表目的的类型.
* 4个整数操作指令. `addq, subq, andq, xorq`, 只能对寄存器数据进行操作.
* 7个跳转指令. `jXX`系列. `jmp, jle, jl, je, jne, jge, jg`
* 6个条件传送指令, `comvXX`系列. `comvle,  cmovl, cmove, cmovne, cmovge, cmovg`
* `call, ret`
* `pushq, popq`和x86-64一致
* `halt`指令停止指令的执行, 并将状态吗设置为HLT

指令编码

每条指令需要1~10个字节不等, 每条指令的第1个字节表明指令的类型, 这个字节分为2部分: 高4位是代码(code)部分, 低4位是功能(function)部分.

机器码示意图

<embed src="http://csapp.cs.cmu.edu/3e/ics3/arch/isa.pdf" width="850" height="700">

以`.`开头的词是**汇编器伪指令（assembler directives）**，它们告诉汇编器调整地址，以便在那产生或插入一些数据。

`.pos 0`告诉汇编器应该从地址0处开始产生代码。

注意`pushq %rsp,popq %rsp`，在`Page 256`

## 逻辑设计和硬件控制语言HCL

一个数字系统需要三个主要的组成部分：

* 计算对位进行操作的函数的组合逻辑
* 存储位的存储器单元
* 控制存储器单元更新的时钟信号

HCL布尔表达式：

* 每个逻辑门的输入必须连接到下述选项之一：一个系统的输入（主输入）、某个存储器单元的输出、某个逻辑门的输出
* 2个或多个逻辑门的输出不能相连
* 这个bool表达式网必须是无环的

**组合电路**从本质上讲，不存储任何信息，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生**时序电路**（sequential circuit），也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。

* 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值
* 随机访问存储器（简称内存）存储多个字，用地址来选择读或写哪个字。

处理一条指令的操作有：

* 取指（fetch）：从内存读取指令字节，地址为程序计数器（PC）的值
* 译码（decode）
* 执行（execute）
* 访存（memory）
* 写回（write back）：最多可以写2个结果到**寄存器文件**
* 更新PC（PC update）：将PC设置成下一条指令的地址

## 流水线

流水线化的一个重要特性就是提高了系统的**吞吐量（throughput）**，也就是单位时间内服务的顾客总数，不过它也会轻微地增加**延迟（latency）**。

