# LearnAssembly
### 额外的工具

将bin文件写入vhd文件中

```
dd if=yourBinPath of=yourVHDPath bs=512 count=1
```

### NASM相关信息

#### NASM命令行编译

```

```

```
# 注意:在windows下,无法直接在cmd中运行这个命令
```

```
# 需要打开软件自带的命令行nasm
```

```
nasm -f bin exam.asm -o exam.bin
```

```
# -f 参数的作用是指定输出文件的格式（Format）
```

```
# -f bin 就是要求 NASM 生成的文件只包含“纯二进制”的内容
```

```
# -o 参数指定编译后输出（Output）的文件名
```

#### NASM特殊字符

```

```

```
$ ;等同于标号,可以看成隐藏在当前行行首的标号
```

```
$$ ;代表当前汇编节(段)的起始汇编地址
```

#### NASM语法

在编译时, 每条指令都会被计算并赋予一个汇编地址, 就像它们已经被加载到内存中的某个段里一样. 

在NASM里,以下3条指令会被编译成一样的结果

```

```

```
infi: jmp near infi
```

```
; -----------------
```

```
infi jmp near infi
```

```
; -----------------
```

```
infi:
```

```
    jmp near infi
```

##### 定义段

使用`SECTION`或者`SEGMENT`来定义段

```

```

```
SECTION 段名称
```

```
; --------------
```

```
SEGMENT 段名称
```

使用`align=n`来使这个段在内存中的起始物理地址为n字节对齐,就是说这个段的起始物理地址必须能被n整除

使用`vstart=n`来使接下来的代码在这个段内偏移n字节,如果不写这句话,那么接下来的**标号**从整个程序的开头开始计算.

```

```

```
SECTION mbr align=16 vstart=0x7c00
```

```
; vstart=0x7c00 有很大的用处,一旦有了这句话,段内的所有语句的汇编地址都将从0x7c00开始计算,如果没有这句话,当我们引用一个标号时,还得手工加上0x7c00
```

使用`section.段名称.start`来获取某个段的汇编地址

### BIOS相关信息

ROM-BIOS会读取硬盘主引导扇区的内容, 并将它加载到内存地址`0x0000:0x7c00`处,然后用jmp指令跳到那里接着执行:

```

```

```
jmp 0x0000:0x7c00
```

### 处理器相关信息

第一条指令`jmp 0xf000:0xe05b`

### 硬盘相关API

- 磁头(Head) [0,1,2......]
- 盘片 [1,2,3......]
- 磁道(Track)
- 柱面(Cylinder)
- 扇区(Sector): 512字节, 每条磁道一般有63个Sector,

表述一个扇区需要的信息: 磁道号, 磁头号和扇区号.

#### 主引导扇区

硬盘的第一个扇区是0面0道1扇区, 或者叫0头0柱1扇区,这个扇区称为主引导扇区. **标志**是最后两个字节应当是`0x55和0xAA`.

```

```

```
; 用dw声明时,应该写成
```

```
dw 0xaa55
```

```
; ------------------
```

```
; 用db声明时,应该写成
```

```
db 0x55
```

```
db 0xaa
```

编写主引导扇区里的代码的时候, 由于主引导扇区会被BIOS加载到内存`0x0000:0x7c00`上, `CS=0x0000`, 所以别忘记了在访问内存时, 在某些场景下将偏移地址加上`0x7c00`.

#### 硬盘访问模式

##### CHS模式

采用Head, Track 和 Sector这种模式来访问硬盘的方法称为**CHS模式**

##### LBA模式

CHS模式不方便, 后来引入了逻辑块地址(Logical Block Address, LBA)的概念. 所以有硬盘都支持这种模式.

LBA模式由硬盘控制器提供服务,不考虑扇区的物理位置(Head,Track),而是把它们全部组织起来统一编号.原先的物理扇区被组织成逻辑扇区, 并且都有唯一的逻辑扇区号.

磁头总数每道扇区数每道扇区数

- C: 物理扇区所在磁道
- H: 物理扇区所在磁头
- S: 物理扇区的扇区号

#### 硬盘访问方法

1. 要读取扇区数量(最多255个)写入`0x1f2`端口
2. 设置起始LBA扇区号(28位数)

| 端口  | 扇区号位数 |
| ----- | ---------- |
| 0x1f3 | 0~7        |
| 0x1f4 | 8~15       |
| 0x1f5 | 16~23      |
| 0x1f6 | 24~27      |

注意: 端口`0x1f6`可以接收8bit的数据, 低4位为扇区号位数的24~27, 但是高4位中有其它的信息

高4位的意义如下

| 7    | 6                   | 5    | 4                         |
| ---- | ------------------- | ---- | ------------------------- |
| 1    | 0: CHS<br /> 1: LBA | 1    | 0: 主硬盘<br /> 1: 从硬盘 |

1. 请求读硬盘. 操作为向端口`0x1f7`写入`0x20`
2. 等待硬盘准备好. 操作为从端口`0x1f7`读入8bit数据, 检查数据的第7位和第3位, 当第7位为0并且第3位为1时,代表硬盘准备好了
3. 连续取出数据. 从端口`0x1f0`读入, 注意这是一个**16**位的端口

### 显卡

显示存储器(Video RAM:VRAM),简称显存,要显示的内容都预先写入显存

地址范围为`0xB8000~0xB8000+0xFFFF`,即`0xB000:0x8000 ~0xB000:0x8000 + 0xFFFF`

ASCII 标识 : Page 71

每个字符占2个字节, 低字节代表ASCII字符,高字节为字符属性(颜色等)

| 背景色(高4位) | 前景色(低4位) |
| ------------- | ------------- |
| KRGB          | IRGB          |
| if(K)闪烁     |               |

### 编写程序相关

#### 加载器相关

在编写的时候要提前确定

- 用户程序起始扇区号(位于什么位置)
- 用户程序被加载的物理起始地址: 起始地址必须16字节对齐,即必须能被16整除

| A0000~FFFFF | ROM BIOS                       |
| ----------- | ------------------------------ |
| 10000~9FFFF | 可用的空间                     |
| 00000~0FFFF | 主引导扇区程序(加载器)及其堆栈 |

#### 用户程序相关

为了能够使引导程序顺利地加载在硬盘里的用户程序来运行,需要提前约定好一些东西, 用户程序中起码要包含以下信息

- **用户程序的尺寸**: 加载器需要知道程序大小,以便决定要读取多少数据
- **应用程序的入口点**: 段地址和偏移地址. 加载器并不知道用户自己定义的程序从那里开始运行, 需要通过这个来告诉加载器,当将用户程序复制到内存后,应该跳转到哪里运行这个用户程序
- **段重定位表**: 用户程序可能包含不止一个段, 加载器将程序加载到内存后, 要确保用户程序内对段的地址访问正确, 加载器需要重新修改段的地址起始位置.